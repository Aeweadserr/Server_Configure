#将nginx进程设置为普通用户，为了安全考虑
user www-data;

#当前启动的worker进程，官方建议是与系统核心数一致
worker_processes auto;

#方式一，就是自动分配绑定
worker_cpu_affinity auto;
pid /var/run/nginx.pid;

include /etc/nginx/modules-enabled/*.conf;

# nginx 进程打开文件描述符数目，此值覆盖 ulimit -n 的值。
worker_rlimit_nofile 2048;

#事件模型
events {
    #使用epoll内核模型
    use epoll;
    #每一个进程可以处理多少个连接，如果是多核可以将连接数调高 worker_processes * 1024
    worker_connections 4096;
}

http {

# Basic Settings
	##

	sendfile on;
	# 设置为非零值时，可限制单个 sendfile() 调用时传输的数据量。如果没有限制，一个快速 连接可能会完全占用工作进程。
    sendfile_max_chunk 5m;
	tcp_nopush on;
	types_hash_max_size 2048;


	include /etc/nginx/mime.types;
	default_type application/octet-stream;
    charset utf-8;  #设置字符集

    client_max_body_size           2048m;
    fastcgi_intercept_errors       on;
    fastcgi_cache_key              $scheme$request_method$host$request_uri;
    fastcgi_cache_use_stale        error timeout invalid_header http_500;
    fastcgi_ignore_headers         Cache-Control Expires Set-Cookie;
    fastcgi_param HTTPS on;
    fastcgi_param HTTP_SCHEME https;
    server_names_hash_max_size     512;
    server_names_hash_bucket_size  128;
    client_header_buffer_size      32k;
    large_client_header_buffers    4 32k;
    fastcgi_buffer_size            64k;
    fastcgi_buffers                4 64k;
    fastcgi_busy_buffers_size      128k;
    fastcgi_temp_file_write_size   256k;

	##
	# Logging Settings
	##
    #设置日志输出格式，根据自己的情况设置
    # quic 日志格式
    log_format quic '$remote_addr - $remote_user [$time_local] '
                    '"$request" $status $body_bytes_sent '
                    '"$http_referer" "$http_user_agent" "$http3"';
	access_log /var/log/nginx/access.log;
	error_log /var/log/nginx/error.log warn; 
	##
	# Gzip Settings     # 启用 gzip 压缩
	##

    gzip                           on;
    gzip_comp_level                6;
    gzip_min_length                1k;
    gzip_disable                   msie6;
    gzip_buffers                   4 16k;
    gzip_http_version              1.1;
    gzip_proxied                   any;
    gzip_vary                      on;
    gzip_types                     text/plain text/css text/xml text/javascript text/x-component application/json application/javascript application/x-javascript application/xml application/xhtml+xml application/rss+xml application/atom+xml application/x-font-ttf application/vnd.ms-fontobject image/svg+xml image/x-icon font/opentype;


    # 启用 brotli 压缩
    brotli                         on;
    brotli_types                   text/plain text/css text/xml text/javascript text/x-component application/json application/javascript application/x-javascript application/xml application/xhtml+xml application/rss+xml application/atom+xml application/x-font-ttf application/vnd.ms-fontobject image/svg+xml image/x-icon font/opentype;
    brotli_static                  on;
    brotli_comp_level              6;
    brotli_buffers                 16 10k;
    brotli_window                  512k;
    brotli_min_length              20;
	##
	# Virtual Host Configs
	##

	include /etc/nginx/conf.d/*.conf;
	include /etc/nginx/sites-enabled/*;

########限制IP登录##########################################################
	geoip2 /usr/share/GeoIP/Country.mmdb {
	auto_reload 5m;
	$geoip2_data_country_code country iso_code;
	}
  	map $geoip2_data_country_code $allowed_country {
                default no;
				CN yes;
				HK yes;
	}
	
#####第一个参数：设置keep-alive客户端连接在服务器端保持开启的超时值（默认75s）；值为0会禁用keep-alive客户端连接；    第二个参数：可选、在响应的header域中设置一个值“Keep-Alive: timeout=time”；通常可以不用设置；
    keepalive_timeout  120s 120s;

########keepalive_requests指令用于设置一个keep-alive连接上可以服务的请求的最大数量，当最大请求数量达到时，连接被关闭。默认是100。这个参数的真实含义，是指一个keep alive建立之后，nginx就会为这个连接设置一个计数器，记录这个keep alive的长连接上已经接收并处理的客户端请求的数量。如果达到这个参数设置的最大值时，则nginx会强行关闭这个长连接，逼迫客户端不得不重新建立新的长连接。大多数情况下当QPS(每秒请求数)不是很高时，默认值100凑合够用。但是，对于一些QPS比较高（比如超过10000QPS，甚至达到30000,50000甚至更高) 的场景，默认的100就显得太低。简单计算一下，QPS=10000时，客户端每秒发送10000个请求(通常建立有多个长连接)，每个连接只能最多跑100次请求，意味着平均每秒钟就会有100个长连接因此被nginx关闭。同样意味着为了保持QPS，客户端不得不每秒中重新新建100个连接。因此，就会发现有大量的TIME_WAIT的socket连接(即使此时keep alive已经在client和nginx之间生效)。因此对于QPS较高的场景，非常有必要加大这个参数，以避免出现大量连接被生成再抛弃的情况，减少TIME_WAIT。 
    keepalive_requests 10000;
    
####limit_conn_zone开辟了一个名称为perip，大小为10M的内存空间用于保存客户端IP
    limit_conn_zone $binary_remote_addr zone=perip:10m;

####limit_conn perip 10表示同一个IP最多10个并发请求    
    limit_conn perip 70;

#####limit_req_zone开辟了一个名称为rs，大小为10M的内存空间用于限制请求速度rate=3r/s表示最多一秒三次（注意这个是速率）    
    limit_req_zone $binary_remote_addr zone=iprs:10m rate=30r/s;

#在所有地方隐藏nginx的版本信息
	server_tokens off;

# Session Ticket
# 可以配置多个密钥，这样做的目的是为了定期更换密钥，保证前向安全性。
# 将更换的密钥配置在上面，Nginx会优先采用上面的密钥进行加/解密，
# 若使用旧密钥加密的会话，上面的密钥解密不了，就使用后面的密钥进行解密。
	ssl_session_tickets on;

#启用 SSL Session 缓存可以减少 TLS 的反复验证，减少 TLS 握手。 1M 的内存就可以缓存 4000 个连接，非常划算，现在内存便宜，尽量开启.
	ssl_session_cache shared:SSL:50m; # 1m 4000个，
	ssl_session_timeout 1d; # 1小时过期 1 hour during which sessions can be re-used.

# ssl证书位置		
	ssl_certificate      /etc/nginx/cert_file/fullchain.pem;
	ssl_certificate_key  /etc/nginx/cert_file/key.crt;

# TLS使用的版本	
	ssl_protocols TLSv1.2 TLSv1.3;
		
# ssl_buffer_size 控制在发送数据时的 buffer 大小，默认情况下，缓冲区设置为16k，为了最大程度地减少TTFB（至第一个字节的时间），最好使用较小的值，这样TTFB可以节省大约30 – 50ms。
	ssl_buffer_size 4k;

# ECC椭圆曲线，不设置Nginx根据OpenSSL选择	
	ssl_ecdh_curve X25519:P-256:P-384:P-521;
		
# 更新更快的 Cipher放前面，这样延迟更小	
	ssl_prefer_server_ciphers on;
	ssl_ciphers "EECDH+aRSA+AES128:EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+ECDSA+AES128:RSA+AES128:EECDH+ECDSA+AES256:EECDH+aRSA+AES256:RSA+AES256:EECDH+ECDSA+3DES:EECDH+aRSA+3DES:TLS13-AES-256-GCM-SHA384:TLS13-CHACHA20-POLY1305-SHA256:TLS13-AES-128-GCM-SHA256:TLS13-AES-128-CCM-8-SHA256:TLS13-AES-128-CCM-SHA256:!NULL:!aNULL:!MD5:!ADH:!RC4:!DH:!DHE:!DES-CBC3-SHA:!AES128-SHA:!AES256-SHA:!AES128-GCM-SHA256:!AES256-GCM-SHA384";

	quic_retry on;
	quic_gso on;
#	quic_mtu 65527;
	quic_active_connection_id_limit 2;
#	quic_timeout 60s;
#	quic_stream_buffer_size 64k;
	http3_stream_buffer_size 64k;
#	http3_max_concurrent_pushes 10;	
	http3_max_concurrent_streams 128;	
#	http3_push_preload on;	
	http3 on;
	
# 指令开启 0-RTT的支持。TLS1.3新特性
	ssl_early_data on;
# 添加 Early-Data 头告知后端, 防止重放攻击
	proxy_set_header Early-Data $ssl_early_data;	

# OCSP stapling
	ssl_stapling off;
	ssl_stapling_verify off;

# replace with the IP address of your resolver
	# resolver 119.29.29.29 valid=60s;
# resolver_timeout表示网络超时时间	
	# resolver_timeout 2s;

#采用HSTS协议的网站将保证浏览器始终连接到该网站的HTTPS加密版本，不需要用户手动在URL地址栏中输入加密地址。# HSTS (ngx_http_headers_module is required) (63072000 seconds)
	add_header	Strict-Transport-Security "max-age=63072000" always;

#HTTP/3 开启
	add_header	Alt-Svc 'h3=":443"; ma=2592000,h3-29=":443"; ma=2592000,h3-Q050=":443"; ma=2592000,h3-Q046=":443"; ma=2592000,h3-Q043=":443"; ma=2592000,quic=":443"; ma=2592000; v="46,43"';
 

#server全局块
 
网站域名
		
	
				proxy_redirect          http:// https://;               # 这个配置
				proxy_set_header        X-Real-IP $remote_addr;
				proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
	
        #return 404;

  		



}

